?sample
is.integer(5)
?is.integer
is.wholenumber(5)
?vapply
?mean
?vapply
sample(1:5, size = 3, replace = TRUE)
sample(1:5, size = 3, replace = TRUE)
sample(1:5, size = 3, replace = TRUE)
sample(1:5, size = 3, replace = TRUE)
sample(1:5, size = 3, replace = TRUE)
sample(1:5, size = 3, replace = TRUE)
sample(1:5, size = 3, replace = TRUE)
sample(1:5, size = 3, replace = TRUE)
sample(1:5, size = 3, replace = TRUE)
sample(1:5, size = 3, replace = TRUE)
sample(1:5, size = 3, replace = TRUE)
set.seed(1337)
sample(1:5, size = 3, replace = TRUE)
sample(1:5, size = 3, replace = TRUE)
sample(1:5, size = 3, replace = TRUE)
sample(1:5, size = 3, replace = TRUE)
sample(1:5, size = 3, replace = TRUE)
sample(1:5, size = 3, replace = TRUE)
sample(1:5, size = 3, replace = TRUE)
sample(1:5, size = 3, replace = TRUE)
set.seed(1337)
sample(1:5, size = 3, replace = TRUE)
sample(1:5, size = 3, replace = TRUE)
sample(1:5, size = 3, replace = TRUE)
sample(1:5, size = 3, replace = TRUE)
SampleFromBox <- function(x, size, replace= TRUE, prob = NULL, iter = 1) {
# Samples tickets from the box.  In the case of one ticket, overrides R's
# default of sampling from 1:x
# Arguments:
#   x - a vector supplying elements from which to choose.  "Tickets in box"
#   size - positive number, size of sample to draw
#   replace - boolean that toggles replacement
#   prob - vector of probability weights or ticket counts
# Returns:
#   A vector of length size with elements drawn from x
if (length(x) <= 1) {
return(rep(x, iter))
} else {
return(vapply(1:iter, function(n){
mean(sample(x, size, replace = replace, prob = prob))
}, FUN.VALUE = 1))
}
}
################################################################################
# Stat 240 - Non-parametric Statistics
# Homework 1
# Due: 02/20/15
# Rebecca Barter
# Andrew Do
# Kellie Ottobonni
################################################################################
# Libraries and seed
set.seed(1337)
################################################################################
# Functions
SampleFromBox <- function(x, size, replace= TRUE, prob = NULL, iter = 1) {
# Samples tickets from the box.  In the case of one ticket, overrides R's
# default of sampling from 1:x
# Arguments:
#   x - a vector supplying elements from which to choose.  "Tickets in box"
#   size - positive number, size of sample to draw
#   replace - boolean that toggles replacement
#   prob - vector of probability weights or ticket counts
# Returns:
#   A vector of length size with elements drawn from x
if (length(x) <= 1) {
return(rep(x, iter))
} else {
return(vapply(1:iter, function(n){
mean(sample(x, size, replace = replace, prob = prob))
}, FUN.VALUE = 1))
}
}
StandardError <- function(x, n) {
# Computes the standard error
# Arguments:
#   x - a vector of ticket values from the box model
#   n - sample size
# Returns
#   standard error of the sample mean in the box model
N <- length(x) # Number of tickets in box
se <- sqrt((N-1)/N/n) * sd(x)
return(se)
}
tickets1 <- c(rep(0, 7), rep(1, 5))
sample1 <- SampleFromBox(x = tickets1, size = 6, replace = TRUE, iter = 100000)
length(sample1)
histogram(sample1)
hist(sample1)
?pbinom
library(dplyr)
?vapply
?pbinom
vapply(1:4, function(z) mean1 + z*se1) %>%
vapply(FUN = function(q) pbinom(q, size = 6, prob = 5/12), FUN.VALUE = 1)
vapply(1:4, function(z) mean1 + z*se1, FUN.VALUE = 1) %>%
vapply(FUN = function(q) pbinom(q, size = 6, prob = 5/12), FUN.VALUE = 1)
vapply(1:4, function(z) mean1 + z*se1, FUN.VALUE = 1)
tickets1 <- c(rep(0, 7), rep(1, 5))
mean1 <- mean(tickets1)
se1 <- StandardError(tickets1, 6)
sample1 <- SampleFromBox(x = tickets1, size = 6, replace = TRUE, iter = 100000)
vapply(1:4, function(z) mean1 + z*se1, FUN.VALUE = 1) %>%
vapply(FUN = function(q) pbinom(q, size = 6, prob = 5/12), FUN.VALUE = 1)
vapply(1:4, function(z) mean1 + z*se1, FUN.VALUE = 1)
vapply(c(0.6179358, 0.8192049, 1.0204740, 1.2217432),FUN = function(q) pbinom(q, size = 6, prob = 5/12), FUN.VALUE = 1)
pbinom(0.6179358, size = 6, prob = 5/12)
pbinom(0.8192049, size = 6, prob = 5/12)
?phyper
?pbinom
ExactProb <- function(max.z = 4, mean, se, cdf, size, ...) {
# Computes the exact probability of P(Xbar > z_i) for z_1, ..., z_max
# Arguments:
#   max.z - max number of standard errors to explore
#   mean - expected value of Xbar
#   se - standard error of xbar
#   cdf - distribution function to use (e.g. pbinom, phyper)
#   n - size of samples
#   ... - arguments to pass to cdf
# Returns:
#   Vector of max.z probabilities
vapply(1:max.z, function(z) size*mean + z * size^2 * se, FUN.VALUE = 1) %>%
vapply(FUN = function(q) cdf(q, ...), FUN.VALUE = 1)
}
vapply(1:4, function(z) 6*mean1 + 36*z*se1, FUN.VALUE = 1) %>%
vapply(FUN = function(q) pbinom(q, size = 6, prob = 5/12), FUN.VALUE = 1)
vapply(1:4, function(z) 6*mean1 + 6*z*se1, FUN.VALUE = 1) %>%
vapply(FUN = function(q) pbinom(q, size = 6, prob = 5/12), FUN.VALUE = 1)
ExactProb <- function(max.z = 4, mean, se, cdf, size, ...) {
# Computes the exact probability of P(Xbar > z_i) for z_1, ..., z_max
# Arguments:
#   max.z - max number of standard errors to explore
#   mean - expected value of Xbar
#   se - standard error of xbar
#   cdf - distribution function to use (e.g. pbinom, phyper)
#   n - size of samples
#   ... - arguments to pass to cdf
# Returns:
#   Vector of max.z probabilities
vapply(1:max.z, function(z) size*mean + z * size * se, FUN.VALUE = 1) %>%
vapply(FUN = function(q) cdf(q, ...), FUN.VALUE = 1)
}
ExactProb(max.z = 4, mean = mean1, se = se1, cdf = pbinom, size = 6)
ExactProb(max.z = 4, mean = mean1, se = se1, cdf = pbinom, n =6,
size = 6, prob = 5/12)
ExactProb <- function(max.z = 4, mean, se, cdf, n, ...) {
# Computes the exact probability of P(Xbar > z_i) for z_1, ..., z_max
# Arguments:
#   max.z - max number of standard errors to explore
#   mean - expected value of Xbar
#   se - standard error of xbar
#   cdf - distribution function to use (e.g. pbinom, phyper)
#   n - size of samples
#   ... - arguments to pass to cdf
# Returns:
#   Vector of max.z probabilities
vapply(1:max.z, function(z) n*mean + z * n * se, FUN.VALUE = 1) %>%
vapply(FUN = function(q) cdf(q, ...), FUN.VALUE = 1)
}
ExactProb(max.z = 4, mean = mean1, se = se1, cdf = pbinom, n =6,
size = 6, prob = 5/12)
vapply(1:4, function(z) 6*mean1 + 6*z*se1, FUN.VALUE = 1) %>%
vapply(FUN = function(q) pbinom(q, size = 6, prob = 5/12), FUN.VALUE = 1)
library(ggplot2)
hist1 <- data.frame(Mean = sample1) %>%
ggplot(aes(x=Mean)) + geom_histogram()
hist1
wao <- 1:5
which(wao < 3)
(wao < 3)
EmpiricalProbEst <- function(max.z = 4, sample, mean, se) {
# Estimates probability of a certain z-score from data
# Arguments:
#   max.z - max number of standard errors to consider
#   sample - data from which to make the estimates
#   mean - expected value of Xbar
#   se - standard error of Xbar
# Returns:
#   Vector of max.z probability estimates
vapply(1:max.z, function(z) mean + z * se, FUN.VALUE = 1) %>%
vapply(FUN = function(q) sum(sample > q))
}
EmpiricalProbEst(max.z = 4, sample = sample1, mean = mean1, se = se1)
EmpiricalProbEst <- function(max.z = 4, sample, mean, se) {
# Estimates probability of a certain z-score from data
# Arguments:
#   max.z - max number of standard errors to consider
#   sample - data from which to make the estimates
#   mean - expected value of Xbar
#   se - standard error of Xbar
# Returns:
#   Vector of max.z probability estimates
vapply(1:max.z, function(z) mean + z * se, FUN.VALUE = 1) %>%
vapply(FUN = function(q) sum(sample > q), FUN.VALUE = 1)
}
EmpiricalProbEst <- function(max.z = 4, sample, mean, se) {
# Estimates probability of a certain z-score from data
# Arguments:
#   max.z - max number of standard errors to consider
#   sample - data from which to make the estimates
#   mean - expected value of Xbar
#   se - standard error of Xbar
# Returns:
#   Vector of max.z probability estimates
vapply(1:max.z, function(z) mean + z * se, FUN.VALUE = 1) %>%
vapply(FUN = function(q) sum(sample > q), FUN.VALUE = 1)
}
EmpiricalProbEst(max.z = 4, sample = sample1, mean = mean1, se = se1)
EmpiricalProbEst <- function(max.z = 4, sample, mean, se) {
# Estimates probability of a certain z-score from data
# Arguments:
#   max.z - max number of standard errors to consider
#   sample - data from which to make the estimates
#   mean - expected value of Xbar
#   se - standard error of Xbar
# Returns:
#   Vector of max.z probability estimates
n <- length(sample)
vapply(1:max.z, function(z) mean + z * se, FUN.VALUE = 1) %>%
vapply(FUN = function(q) sum(sample > q)/n, FUN.VALUE = 1)
}
?pbinom
ExactProb <- function(max.z = 4, mean, se, cdf, n, ...) {
# Computes the exact probability of P(Xbar > z_i) for z_1, ..., z_max
# Arguments:
#   max.z - max number of standard errors to consider
#   mean - expected value of Xbar
#   se - standard error of xbar
#   cdf - distribution function to use (e.g. pbinom, phyper)
#   n - size of samples
#   ... - arguments to pass to cdf
# Returns:
#   Vector of max.z probabilities
vapply(1:max.z, function(z) n*mean + z * n * se, FUN.VALUE = 1) %>%
vapply(FUN = function(q) cdf(q, lower.tail = FALSE, ...), FUN.VALUE = 1)
}
EmpiricalProbEst <- function(max.z = 4, sample, mean, se) {
# Estimates probability of a certain z-score from data
# Arguments:
#   max.z - max number of standard errors to consider
#   sample - data from which to make the estimates
#   mean - expected value of Xbar
#   se - standard error of Xbar
# Returns:
#   Vector of max.z probability estimates
n <- length(sample)
vapply(1:max.z, function(z) mean + z * se, FUN.VALUE = 1) %>%
vapply(FUN = function(q) sum(sample > q)/n, FUN.VALUE = 1)
}
ExactProb(max.z = 4, mean = mean1, se = se1, cdf = pbinom, n = 6,
size = 6, prob = 5/12)
EmpiricalProbEst(max.z = 4, sample = sample1, mean = mean1, se = se1)
StandardError <- function(x, n, replacement = TRUE) {
# Computes the standard error
# Arguments:
#   x - a vector of ticket values from the box model
#   n - sample size
# Returns
#   standard error of the sample mean in the box model
N <- length(x) # Number of tickets in box
if (replacement) {
se <- sqrt((N-1)/N/n) * sd(x)
} else {
# Finite population correction
se <- sqrt((N-n)/N/n) * sd(x)
}
return(se)
}
?pnorm
NormalProbEst <- function(max.z = 4, mean, se) {
# Estimates probability of a certain z-score using normal approximation
# with continuity correction
# Arguments:
#   max.z - max number of standard errors to consider
#   mean - expected value of Xbar
#   se - standard error of Xbar
# Returns:
#   Vector of max.z probability estimates
vapply(1:max.z, function(z) mean + z * se, FUN.VALUE = 1) %>%
vapply(FUN = function(q) pnorm(q, mean = mean, sd = se), FUN.VALUE = 1)
}
NormalProbEst(max.z = 4, mean = mean1, se = se1)
NormalProbEst <- function(max.z = 4, mean, se) {
# Estimates probability of a certain z-score using normal approximation
# with continuity correction
# Arguments:
#   max.z - max number of standard errors to consider
#   mean - expected value of Xbar
#   se - standard error of Xbar
# Returns:
#   Vector of max.z probability estimates
vapply(1:max.z, function(z) mean + z * se, FUN.VALUE = 1) %>%
vapply(FUN = function(q) {
pnorm(q + 1/2, mean = mean, sd = se, lower.tail = FALSE)
}, FUN.VALUE = 1)
}
NormalProbEst(max.z = 4, mean = mean1, se = se1)
EmpiricalProbEst(max.z = 4, sample = sample1, mean = mean1, se = se1)
ExactProb(max.z = 4, mean = mean1, se = se1, cdf = pbinom, n = 6,
size = 6, prob = 5/12)
mean1
mean1 + se1
5/12
NormalProbEst <- function(max.z = 4, mean, se, n) {
# Estimates probability of a certain z-score using normal approximation
# with continuity correction
# Arguments:
#   max.z - max number of standard errors to consider
#   mean - expected value of Xbar
#   se - standard error of Xbar
#   n - the size of the samples
# Returns:
#   Vector of max.z probability estimates
vapply(1:max.z, function(z) mean + z * se, FUN.VALUE = 1) %>%
vapply(FUN = function(q) {
pnorm(q + 1/2, mean = mean, sd = se, lower.tail = FALSE)
}, FUN.VALUE = 1)
}
NormalProbEst <- function(max.z = 4, mean, se, n) {
# Estimates probability of a certain z-score using normal approximation
# with continuity correction
# Arguments:
#   max.z - max number of standard errors to consider
#   mean - expected value of Xbar
#   se - standard error of Xbar
#   n - the size of the samples
# Returns:
#   Vector of max.z probability estimates
vapply(1:max.z, function(z) mean + z * se, FUN.VALUE = 1) %>%
vapply(FUN = function(q) {
pnorm(q + 1/2, mean = n*mean, sd = n*se, lower.tail = FALSE)
}, FUN.VALUE = 1)
}
NormalProbEst(max.z = 4, mean = mean1, se = se1, n = 6)
NormalProbEst <- function(max.z = 4, mean, se, n) {
# Estimates probability of a certain z-score using normal approximation
# with continuity correction
# Arguments:
#   max.z - max number of standard errors to consider
#   mean - expected value of Xbar
#   se - standard error of Xbar
#   n - the size of the samples
# Returns:
#   Vector of max.z probability estimates
vapply(1:max.z, function(z) n * mean + n * z * se, FUN.VALUE = 1) %>%
vapply(FUN = function(q) {
pnorm(q + 1/2, mean = n*mean, sd = n*se, lower.tail = FALSE)
}, FUN.VALUE = 1)
}
NormalProbEst(max.z = 4, mean = mean1, se = se1, n = 6)
NormalProbEst <- function(max.z = 4, mean, se, n) {
# Estimates probability of a certain z-score using normal approximation
# with continuity correction
# Arguments:
#   max.z - max number of standard errors to consider
#   mean - expected value of Xbar
#   se - standard error of Xbar
#   n - the size of the samples
# Returns:
#   Vector of max.z probability estimates
vapply(1:max.z, function(z) mean + z * se, FUN.VALUE = 1) %>%
vapply(FUN = function(q) {
pnorm(q + 1/2, mean = n*mean, sd = n*se, lower.tail = FALSE)
}, FUN.VALUE = 1)
}
NormalProbEst <- function(max.z = 4, mean, se, n) {
# Estimates probability of a certain z-score using normal approximation
# with continuity correction
# Arguments:
#   max.z - max number of standard errors to consider
#   mean - expected value of Xbar
#   se - standard error of Xbar
#   n - the size of the samples
# Returns:
#   Vector of max.z probability estimates
vapply(1:max.z, function(z) mean + z * se, FUN.VALUE = 1) %>%
vapply(FUN = function(q) {
pnorm(q - 1/2, mean = mean, sd = se, lower.tail = FALSE)
}, FUN.VALUE = 1)
}
NormalProbEst(max.z = 4, mean = mean1, se = se1, n = 6)
EmpiricalProbEst(max.z = 4, sample = sample1, mean = mean1, se = se1)
hist1 + stat_function(data=data.frame(x=c(0,1)), aes(x=x), pnorm(mean=mean1, sd=se1)
)
?stat_function
hist1 + stat_function(data=data.frame(x=c(0,1)), aes(x=x), fun=pnorm(mean=mean1, sd=se1))
hist1 + stat_function(data=data.frame(x=c(0,1)), aes(x=x), fun=pnorm(q=x,mean=mean1, sd=se1))
hist1 + stat_function(data=data.frame(x=c(0,1)), aes(x=x), fun=pnorm, arg=list(mean=mean1, sd=se1))
ggplot() + stat_function(data=data.frame(x=c(0,1)), aes(x=x), fun=pnorm, arg=list(mean=mean1, sd=se1))
hist1 <- data.frame(Mean = sample1) %>%
ggplot(aes(x=Mean)) + geom_histogram()
ggplot() + stat_function(data=data.frame(x=c(0,1)), aes(x=x), fun=dnorm, arg=list(mean=mean1, sd=se1))
ggplot() + stat_function(data=data.frame(x=c(0,1)), aes(x=x), fun=dnorm, arg=list(mean=mean1, sd=se1))
hist1 + stat_function(data=data.frame(x=c(0,1)), aes(x=x), fun=dnorm, arg=list(mean=mean1, sd=se1))
?geom_histogram
hist1 <- data.frame(Mean = sample1) %>%
ggplot(aes(x=Mean)) + geom_histogram(aes( y=..density..)) +
stat_function(data=data.frame(x=c(0,1)), aes(x=x), fun=dnorm, arg=list(mean=mean1, sd=se1))
hist1 <- data.frame(Mean = sample1) %>%
ggplot(aes(x=Mean)) + geom_histogram(aes( y=..density..))
hist1 <- data.frame(Mean = sample1) %>%
ggplot(aes(x=Mean)) + geom_histogram()
data.frame(Mean = sample1) %>%
ggplot(aes(x=Mean)) + geom_histogram(aes( y=..density..)) +
stat_function(data=data.frame(x=c(0,1)), aes(x=x), fun=dnorm, arg=list(mean=mean1, sd=se1))
data.frame(Mean = sample1) %>%
ggplot(aes(x=Mean)) + geom_histogram(aes( y=..ncount..)) +
stat_function(data=data.frame(x=c(0,1)), aes(x=x), fun=dnorm, arg=list(mean=mean1, sd=se1))
data.frame(Mean = sample1) %>%
ggplot(aes(x=Mean)) + geom_histogram(aes( y=..density..)) +
stat_function(data=data.frame(x=c(0,1)), aes(x=x), fun=dnorm, arg=list(mean=6*mean1, sd=6*se1))
data.frame(Mean = sample1) %>%
ggplot(aes(x=Mean)) + geom_histogram(aes( y=..density..)) +
stat_function(data=data.frame(x=c(0,1)), aes(x=x), fun=dnorm, arg=list(mean=6*mean1, sd=se1))
data.frame(Mean = sample1) %>%
ggplot(aes(x=Mean)) + geom_histogram(aes( y=..density..)) +
stat_function(data=data.frame(x=c(0,1)), aes(x=x), fun=dnorm, arg=list(mean=mean1, sd=se1))
data.frame(Mean = sample1) %>%
ggplot(aes(x=Mean)) + geom_histogram(aes( y=..density..), binwidth = .1)
data.frame(Mean = sample1) %>%
ggplot(aes(x=Mean)) + geom_histogram(aes( y=..density..), binwidth = .1) +
stat_function(data=data.frame(x=c(0,1)), aes(x=x), fun=dnorm, arg=list(mean=mean1, sd=se1))
data.frame(Mean = sample1) %>%
ggplot(aes(x=Mean)) + geom_histogram(aes( y=..density..), binwidth = .05) +
stat_function(data=data.frame(x=c(0,1)), aes(x=x), fun=dnorm, arg=list(mean=mean1, sd=se1))
data.frame(Mean = sample1) %>%
ggplot(aes(x=Mean)) + geom_histogram(aes( y=..density..), binwidth = .2) +
stat_function(data=data.frame(x=c(0,1)), aes(x=x), fun=dnorm, arg=list(mean=mean1, sd=se1))
data.frame(Mean = sample1) %>%
ggplot(aes(x=Mean)) + geom_histogram(aes( y=..density..), binwidth = .15) +
stat_function(data=data.frame(x=c(0,1)), aes(x=x), fun=dnorm, arg=list(mean=mean1, sd=se1))
NormalProbEst <- function(max.z = 4, mean, se, n) {
# Estimates probability of a certain z-score using normal approximation
# with continuity correction
# Arguments:
#   max.z - max number of standard errors to consider
#   mean - expected value of Xbar
#   se - standard error of Xbar
#   n - the size of the samples
# Returns:
#   Vector of max.z probability estimates
vapply(1:max.z, function(z) n*mean + z * n * se, FUN.VALUE = 1) %>%
vapply(FUN = function(q) {
pnorm(q - 1/2, mean = n*mean, sd = n*se, lower.tail = FALSE)
}, FUN.VALUE = 1)
}
ExactProb(max.z = 4, mean = mean1, se = se1, cdf = pbinom, n = 6,
size = 6, prob = 5/12)
EmpiricalProbEst(max.z = 4, sample = sample1, mean = mean1, se = se1)
NormalProbEst(max.z = 4, mean = mean1, se = se1, n = 6)
